#!/bin/bash

echo "üîß ‰øÆÂæ©Ë≥áÊñôÂ∫´ÂïüÂãïÈ†ÜÂ∫èÂïèÈ°å"
echo "=========================="

# ===== 1. ‰øÆÂæ© app.ts - Âª∂ÈÅ≤Ë∑ØÁî±ÂàùÂßãÂåñ =====
echo "üìù ‰øÆÂæ© app.ts..."

cat > backend/src/app.ts << 'EOF'
import express from 'express';
import cors from 'cors';
import helmet from 'helmet';
import session from 'express-session';
import path from 'path';
import { connectDatabase } from './database/connection';
import { logger } from './utils/logger';
import { sessionConfig } from './config/session';

const app = express();
const PORT = process.env.PORT || 3000;

// Âü∫Êú¨‰∏≠Èñì‰ª∂
app.use(helmet());
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:5173',
  credentials: true
}));

app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true, limit: '10mb' }));

// Session ÈÖçÁΩÆ
app.use(session(sessionConfig));

// ÈùúÊÖãÊ™îÊ°àÊúçÂãô
app.use('/uploads', express.static(path.join(__dirname, '../uploads')));

// Âü∫Êú¨ÂÅ•Â∫∑Ê™¢Êü•Ôºà‰∏ç‰æùË≥¥Ë≥áÊñôÂ∫´Ôºâ
app.get('/health', (req, res) => {
  res.json({
    status: 'healthy',
    timestamp: new Date().toISOString(),
    services: {
      server: 'running',
      session: 'active'
    }
  });
});

// Ê†πË∑ØÂæë
app.get('/', (req, res) => {
  res.json({
    message: 'Dynamic Form System Backend',
    version: '1.0.0',
    status: 'running',
    timestamp: new Date().toISOString()
  });
});

// ÂïüÂãïÊúçÂãôÂô®
async function startServer() {
  try {
    // ÂÖàÈÄ£Êé•Ë≥áÊñôÂ∫´
    await connectDatabase();
    logger.info('Database connected successfully');

    // Ë≥áÊñôÂ∫´ÈÄ£Êé•ÊàêÂäüÂæåÔºåÂÜçÂ∞éÂÖ•‰∏¶Ë®≠ÁΩÆË∑ØÁî±
    const authRoutes = (await import('./routes/auth.routes')).default;
    const userRoutes = (await import('./routes/user.routes')).default;
    const adminRoutes = (await import('./routes/admin.routes')).default;
    const projectsRoutes = (await import('./routes/projects.routes')).default;

    // Ë®ªÂÜä API Ë∑ØÁî±
    app.use('/api/auth', authRoutes);
    app.use('/api/user', userRoutes);
    app.use('/api/admin', adminRoutes);
    app.use('/api/projects', projectsRoutes);

    // Êõ¥Êñ∞ÂÅ•Â∫∑Ê™¢Êü•‰ª•ÂåÖÂê´Ë≥áÊñôÂ∫´ÁãÄÊÖã
    app.get('/api/health', (req, res) => {
      res.json({
        status: 'healthy',
        timestamp: new Date().toISOString(),
        services: {
          database: 'connected',
          session: 'active',
          auth: 'ready',
          projects: {
            bmi: 'ready',
            tdee: 'ready'
          }
        }
      });
    });

    // 404 ËôïÁêÜ
    app.use((req, res) => {
      res.status(404).json({
        success: false,
        error: 'Route not found',
        code: 'ROUTE_NOT_FOUND',
        path: req.path
      });
    });

    // ÈåØË™§ËôïÁêÜ
    app.use((err: any, req: express.Request, res: express.Response, next: express.NextFunction) => {
      logger.error('Express error:', err);
      res.status(err.status || 500).json({
        success: false,
        error: 'Internal server error',
        code: 'INTERNAL_SERVER_ERROR'
      });
    });

    app.listen(PORT, () => {
      logger.info(`üöÄ Server is running on port ${PORT}`);
      logger.info(`üåç Environment: ${process.env.NODE_ENV || 'development'}`);
      logger.info(`üè• Health check: http://localhost:${PORT}/health`);
      logger.info(`üè• API Health check: http://localhost:${PORT}/api/health`);
    });
  } catch (error) {
    logger.error('Failed to start server:', error);
    process.exit(1);
  }
}

// ÂÑ™ÈõÖÈóúÈñâ
process.on('SIGTERM', () => {
  logger.info('SIGTERM received, shutting down gracefully');
  process.exit(0);
});

process.on('SIGINT', () => {
  logger.info('SIGINT received, shutting down gracefully');
  process.exit(0);
});

process.on('unhandledRejection', (reason, promise) => {
  logger.error('Unhandled Rejection:', { reason, promise });
});

process.on('uncaughtException', (error) => {
  logger.error('Uncaught Exception:', error);
  process.exit(1);
});

startServer();

export default app;
EOF

# ===== 2. ‰øÆÂæ© BMI Model - Âª∂ÈÅ≤Ê±†ÂàùÂßãÂåñ =====
echo "üìù ‰øÆÂæ© BMI Model..."

cat > backend/src/projects/bmi/models/BMIRecord.ts << 'EOF'
import { Pool } from 'pg';
import { logger } from '../../../utils/logger';

export interface BMIRecord {
  id: string;
  user_id: string;
  height: number;
  weight: number;
  bmi: number;
  category: string;
  age?: number;
  gender?: string;
  created_at: Date;
  updated_at: Date;
}

export interface BMICalculationRequest {
  height: number;
  weight: number;
  age?: number;
  gender?: string;
}

export interface BMICalculationResult {
  bmi: number;
  category: string;
  isHealthy: boolean;
}

export class BMIModel {
  private getPool(): Pool {
    // Âª∂ÈÅ≤Â∞éÂÖ• poolÔºåÁ¢∫‰øùË≥áÊñôÂ∫´Â∑≤ÈÄ£Êé•
    const { pool } = require('../../../database/connection');
    return pool;
  }

  async create(userId: string, data: BMICalculationRequest & BMICalculationResult): Promise<BMIRecord> {
    try {
      const query = `
        INSERT INTO bmi_records (user_id, height, weight, bmi, category, age, gender)
        VALUES ($1, $2, $3, $4, $5, $6, $7)
        RETURNING *
      `;
      
      const values = [
        userId,
        data.height,
        data.weight,
        data.bmi,
        data.category,
        data.age || null,
        data.gender || null
      ];

      const result = await this.getPool().query(query, values);
      logger.debug(`BMI record created for user ${userId}`);
      return result.rows[0];
    } catch (error) {
      logger.error('Error creating BMI record:', error);
      throw new Error('Failed to create BMI record');
    }
  }

  async findByUserId(userId: string, limit: number = 50): Promise<BMIRecord[]> {
    try {
      const query = `
        SELECT * FROM bmi_records 
        WHERE user_id = $1 
        ORDER BY created_at DESC 
        LIMIT $2
      `;
      
      const result = await this.getPool().query(query, [userId, limit]);
      return result.rows;
    } catch (error) {
      logger.error('Error finding BMI records:', error);
      throw new Error('Failed to find BMI records');
    }
  }

  async findLatestByUserId(userId: string): Promise<BMIRecord | null> {
    try {
      const query = `
        SELECT * FROM bmi_records 
        WHERE user_id = $1 
        ORDER BY created_at DESC 
        LIMIT 1
      `;
      
      const result = await this.getPool().query(query, [userId]);
      return result.rows.length > 0 ? result.rows[0] : null;
    } catch (error) {
      logger.error('Error getting latest BMI record:', error);
      throw new Error('Failed to get latest BMI record');
    }
  }

  async delete(recordId: string, userId: string): Promise<boolean> {
    try {
      const query = `DELETE FROM bmi_records WHERE id = $1 AND user_id = $2 RETURNING id`;
      const result = await this.getPool().query(query, [recordId, userId]);
      return result.rowCount > 0;
    } catch (error) {
      logger.error('Error deleting BMI record:', error);
      throw new Error('Failed to delete BMI record');
    }
  }

  async clearUserHistory(userId: string): Promise<number> {
    try {
      const query = `DELETE FROM bmi_records WHERE user_id = $1 RETURNING id`;
      const result = await this.getPool().query(query, [userId]);
      return result.rowCount;
    } catch (error) {
      logger.error('Error clearing BMI history:', error);
      throw new Error('Failed to clear BMI history');
    }
  }

  async getRecordCount(userId: string): Promise<number> {
    try {
      const query = `SELECT COUNT(*) as count FROM bmi_records WHERE user_id = $1`;
      const result = await this.getPool().query(query, [userId]);
      return parseInt(result.rows[0].count);
    } catch (error) {
      logger.error('Error getting BMI record count:', error);
      throw new Error('Failed to get BMI record count');
    }
  }
}
EOF

# ===== 3. ‰øÆÂæ©Ë≥áÊñôÂ∫´ÈÄ£Êé•ÈÖçÁΩÆ =====
echo "üìù ‰øÆÂæ©Ë≥áÊñôÂ∫´ÈÄ£Êé•..."

cat > backend/src/database/connection.ts << 'EOF'
import { Pool } from 'pg';
import { logger } from '../utils/logger';

let pool: Pool | null = null;
let isConnected = false;

export const connectDatabase = async (): Promise<void> => {
  try {
    if (pool && isConnected) {
      logger.info('Database already connected');
      return;
    }

    pool = new Pool({
      host: process.env.DATABASE_HOST || 'localhost',
      port: parseInt(process.env.DATABASE_PORT || '5432'),
      database: process.env.DATABASE_NAME || 'dynamic_form_system',
      user: process.env.DATABASE_USER || 'postgres',
      password: process.env.DATABASE_PASSWORD || 'postgres123',
      max: 20,
      idleTimeoutMillis: 30000,
      connectionTimeoutMillis: 2000,
    });

    const client = await pool.connect();
    logger.info('Database connected successfully', {
      host: process.env.DATABASE_HOST || 'localhost',
      database: process.env.DATABASE_NAME || 'dynamic_form_system',
      user: process.env.DATABASE_USER || 'postgres'
    });
    
    client.release();
    isConnected = true;
  } catch (error) {
    logger.error('Database connection failed:', error);
    throw error;
  }
};

export const closeDatabase = async (): Promise<void> => {
  try {
    if (pool) {
      await pool.end();
      pool = null;
      isConnected = false;
      logger.info('Database connection closed');
    }
  } catch (error) {
    logger.error('Error closing database connection:', error);
  }
};

export const query = async (text: string, params?: any[]): Promise<any> => {
  if (!pool || !isConnected) {
    throw new Error('Database not connected. Call connectDatabase() first.');
  }
  
  try {
    const result = await pool.query(text, params);
    return result;
  } catch (error) {
    logger.error('Database query error:', error);
    throw error;
  }
};

export const getPool = (): Pool => {
  if (!pool || !isConnected) {
    throw new Error('Database not connected. Call connectDatabase() first.');
  }
  return pool;
};

// Â∞éÂá∫ pool ÁÇ∫‰∫ÜÂêëÂæåÁõ∏ÂÆπ
export { pool };
EOF

# ===== 4. ÂâµÂª∫Âø´ÈÄüË≥áÊñôÂ∫´ÂàùÂßãÂåñËÖ≥Êú¨ =====
echo "üìù ÂâµÂª∫Ë≥áÊñôÂ∫´ÂàùÂßãÂåñËÖ≥Êú¨..."

cat > backend/init-database.sh << 'EOF'
#!/bin/bash

echo "üîß ÂàùÂßãÂåñË≥áÊñôÂ∫´"
echo "=============="

# Ê™¢Êü• PostgreSQL ÊòØÂê¶ÈÅãË°å
if ! nc -z localhost 5432 2>/dev/null; then
    echo "‚ùå PostgreSQL Êú™ÈÅãË°åÂú® localhost:5432"
    echo "Ë´ãÁ¢∫‰øù PostgreSQL Ê≠£Âú®ÈÅãË°åÊàñ‰ΩøÁî® Docker:"
    echo "docker-compose up -d postgres"
    exit 1
fi

echo "‚úÖ PostgreSQL ÈÄ£Êé•Ê≠£Â∏∏"

# ÈÅãË°åË≥áÊñôÂ∫´ÂàùÂßãÂåñ
npm run init-db

echo "üéâ Ë≥áÊñôÂ∫´ÂàùÂßãÂåñÂÆåÊàê"
EOF

chmod +x backend/init-database.sh

echo ""
echo "üéØ ‰øÆÂæ©ÂÆåÊàêÔºÅ‰∏ªË¶ÅÊîπÂãïÔºö"
echo "‚úÖ ‰øÆÂæ©‰∫Ü app.ts ÁöÑÂïüÂãïÈ†ÜÂ∫è - ÂÖàÈÄ£Êé•Ë≥áÊñôÂ∫´ÂÜçËºâÂÖ•Ë∑ØÁî±"
echo "‚úÖ ‰øÆÂæ©‰∫Ü BMI Model ÁöÑÊ±†ÂàùÂßãÂåñ - ‰ΩøÁî®Âª∂ÈÅ≤ËºâÂÖ•"
echo "‚úÖ ÊîπÂñÑ‰∫ÜË≥áÊñôÂ∫´ÈÄ£Êé•ÁÆ°ÁêÜ"
echo "‚úÖ ÂâµÂª∫‰∫ÜË≥áÊñôÂ∫´ÂàùÂßãÂåñËÖ≥Êú¨"
echo ""
echo "üöÄ ÁèæÂú®ÂèØ‰ª•ÂòóË©¶ÂïüÂãïÔºö"
echo "1. cd backend && npm run init-db  # ÂàùÂßãÂåñË≥áÊñôÂ∫´"
echo "2. cd backend && npm run dev      # ÂïüÂãïÂæåÁ´Ø"